import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

public class SBClient {
    private final AttachmentService attachmentService;
    private final AssignmentLockedService assignmentLockedService;
    private final ContactService contactService;
    private final AtomTaskListDataRetriever atomTaskListDataRetriever;

    public SBClient(AttachmentService attachmentService, 
                    AssignmentLockedService assignmentLockedService, 
                    ContactService contactService, 
                    AtomTaskListDataRetriever atomTaskListDataRetriever) {
        this.attachmentService = attachmentService;
        this.assignmentLockedService = assignmentLockedService;
        this.contactService = contactService;
        this.atomTaskListDataRetriever = atomTaskListDataRetriever;
    }

    // Custom exception for timeout
    public static class CaseProcessingTimeoutException extends RuntimeException {
        public CaseProcessingTimeoutException(String message, Throwable cause) {
            super(message, cause);
        }
    }

    public CompletableFuture<Map<String, Object>> processCase(String caseId) {
        ExecutorService executor = Executors.newFixedThreadPool(10);

        // Define all async tasks with timeouts
        CompletableFuture<List<Attachment>> attachmentFuture = CompletableFuture.supplyAsync(() ->
            attachmentService.findByCaseIdAndReferenceId(caseId, "case"), executor)
            .orTimeout(5, TimeUnit.SECONDS);

        CompletableFuture<Boolean> isCaseLockedFuture = CompletableFuture.supplyAsync(() ->
            assignmentLockedService.isCaseLocked(caseId), executor)
            .orTimeout(5, TimeUnit.SECONDS);

        CompletableFuture<ActivityCase> activityCaseFuture = CompletableFuture.supplyAsync(() -> {
            // Simulate activity case retrieval
            return new ActivityCase(); // Replace with actual logic
        }, executor)
            .orTimeout(5, TimeUnit.SECONDS);

        CompletableFuture<List<OutgoingEmail>> outgoingEmailFuture = CompletableFuture.supplyAsync(() -> {
            // Simulate outgoing email retrieval
            return new ArrayList<>(); // Replace with actual logic
        }, executor)
            .orTimeout(5, TimeUnit.SECONDS);

        // Placeholder for other futures (e.g., complaintLinkDetails, etc.)
        CompletableFuture<Contact> contactFuture = activityCaseFuture.thenCompose(activityCase ->
            CompletableFuture.supplyAsync(() ->
                contactService.findByContactId(activityCase.getClientContactId()), executor)
                .orTimeout(5, TimeUnit.SECONDS)
        );

        CompletableFuture<List<Contact>> contactListFuture = activityCaseFuture.thenCompose(activityCase ->
            CompletableFuture.supplyAsync(() ->
                contactService.findByClientId(activityCase.getClientId()), executor)
                .orTimeout(5, TimeUnit.SECONDS)
        );

        CompletableFuture<List<CaseContentDataRetriever>> caseContentFuture = CompletableFuture.supplyAsync(() ->
            atomTaskListDataRetriever.retrieveAllAtomTasksFromTheAtomWorkflow(), executor)
            .orTimeout(5, TimeUnit.SECONDS);

        // Collect all futures
        List<CompletableFuture<?>> allFuturesList = Arrays.asList(
            attachmentFuture, isCaseLockedFuture, activityCaseFuture, outgoingEmailFuture,
            contactFuture, contactListFuture, caseContentFuture
        );

        // Wait for all futures to complete
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(allFuturesList.toArray(new CompletableFuture[0]));

        // Collect results and handle exceptions
        return allFutures.thenApply(v -> {
            // Check for any failed futures
            for (CompletableFuture<?> future : allFuturesList) {
                if (future.isCompletedExceptionally()) {
                    try {
                        future.join(); // This will throw the exception
                    } catch (CompletionException e) {
                        throw new CaseProcessingTimeoutException("One or more tasks timed out or failed for caseId: " + caseId, e.getCause());
                    }
                }
            }

            // If all futures completed successfully, collect results
            Map<String, Object> results = new HashMap<>();
            results.put("attachments", attachmentFuture.join());
            results.put("isCaseLocked", isCaseLockedFuture.join());
            results.put("activityCase", activityCaseFuture.join());
            results.put("outgoingEmails", outgoingEmailFuture.join());
            results.put("contact", contactFuture.join());
            results.put("contactList", contactListFuture.join());
            results.put("caseContent", caseContentFuture.join());
            return results;
        }).whenComplete((result, throwable) -> {
            executor.shutdown(); // Clean up executor
        });
    }

    // Placeholder classes for context
    static class ActivityCase {
        String getClientContactId() { return "contactId"; }
        String getClientId() { return "clientId"; }
    }

    static class AttachmentService {
        List<Attachment> findByCaseIdAndReferenceId(String caseId, String referenceId) {
            try {
                Thread.sleep(6000); // Simulate timeout
                return new ArrayList<>();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    static class AssignmentLockedService {
        boolean isCaseLocked(String caseId) { return false; }
    }

    static class ContactService {
        Contact findByContactId(String contactId) { return new Contact(); }
        List<Contact> findByClientId(String clientId) { return new ArrayList<>(); }
    }

    static class AtomTaskListDataRetriever {
        List<CaseContentDataRetriever> retrieveAllAtomTasksFromTheAtomWorkflow() {
            return new ArrayList<>();
        }
    }

    static class Contact {}
    static class Attachment {}
    static class CaseContentDataRetriever {}

    public static void main(String[] args) {
        SBClient client = new SBClient(new AttachmentService(), new AssignmentLockedService(),
                                      new ContactService(), new AtomTaskListDataRetriever());
        CompletableFuture<Map<String, Object>> future = client.processCase("case123");
        future.thenAccept(System.out::println)
              .exceptionally(throwable -> {
                  System.err.println("Error: " + throwable.getMessage());
                  return null;
              });

        try {
            Thread.sleep(7000); // Keep main thread alive
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}