function convertDateTimeFormat(dateTimeString) {
    // Extract date and time using regex
    let match = dateTimeString.match(/(\d{4}-\d{2}-\d{2}) (\d{1,2}):(\d{2})(AM|PM)/i);

    if (!match) return null; // Return null if format doesn't match

    let [_, date, hour, minute, period] = match;

    // Convert hour to 24-hour format
    hour = parseInt(hour);
    if (period.toUpperCase() === "PM" && hour !== 12) {
        hour += 12;
    } else if (period.toUpperCase() === "AM" && hour === 12) {
        hour = 0;
    }

    // Format hour and minute as two digits
    let formattedTime = `${String(hour).padStart(2, '0')}:00:00`;

    return `${date}T${formattedTime}`;
}

// Example Usage
let input = "2025-02-27 02:00AM";
let output = convertDateTimeFormat(input);
console.log(output); // Output: "2025-02-27T02:


00:00"

function convertToAMPMFormat(isoString) {
    // Extract date and time using regex
    let match = isoString.match(/(\d{4}-\d{2}-\d{2})T(\d{2}):\d{2}:\d{2}/);
    
    if (!match) return null; // Return null if format doesn't match

    let [_, date, hour] = match;
    hour = parseInt(hour);

    // Determine AM or PM
    let period = hour >= 12 ? "PM" : "AM";

    // Convert to 12-hour format
    let hour12 = hour % 12 || 12; // 0 → 12, 13 → 1, etc.

    return `${date} ${hour12}:00${period}`;
}

function convertToAMPMFormat(isoString) {
    // Extract date and time using regex
    let match = isoString.match(/(\d{4}-\d{2}-\d{2})T(\d{2}):(\d{2}):\d{2}/);
    
    if (!match) return null; // Return null if format doesn't match

    let [_, date, hour, minute] = match;
    hour = parseInt(hour);

    // Determine AM or PM
    let period = hour >= 12 ? "PM" : "AM";

    // Convert to 12-hour format
    let hour12 = hour % 12 || 12; // 0 → 12, 13 → 1, etc.

    return `${date} ${hour12}:${minute}${period}`;
}

// Exa

Subject: Request for Discussion on 2024 Year-End Review

Hi Sahil,

I hope this message finds you well. I wanted to kindly share that since joining the bank nearly two years ago, I haven’t received an increment, which is a first in my career. Despite my dedicated efforts—single-handedly maintaining the activity module and contributing over 6 FTEs to the TW SSOPS project along with other initiatives, all with no escalations, and earning appreciation from the respective teams—I feel this might not be fully reflected in my compensation. While my peers at the same level typically handle a single component, I’ve gone above and beyond, working countless nights and weekends, even undergoing surgery due to prolonged sitting. However, my bonus, which was already on the lower side, has only increased by an additional MYR 10k.

Could we please schedule a time to discuss this at your convenience? I would deeply appreciate your insights and guidance on this matter.

Warm regards,Akash Sharma

This version maintains a highly polite and respectful tone, softens the language, and emphasizes gratitude while clearly conveying your concerns. Let me know if you’d like further refinements!



//

Dear Sahil,

I hope you’re doing well. Thank you for scheduling our call tomorrow to discuss my 2024 Year-End Review and for your recent email. I truly appreciate your leadership and the opportunity to review my performance and compensation.

To prepare effectively, I’d be grateful for your guidance on a few points:

	1.	Current Compensation and Market Positioning:You mentioned my salary of 127,650 MYR is 27.66% above the market median for Band 7, and I was hired above market median, but I haven’t received an increase in two years. I’m concerned this trend might continue, risking alignment with industry benchmarks. Could you kindly share the market data or criteria used to determine this positioning?
	2.	Potential 30% Increase (MYR 10k):Thank you for suggesting a 30% increase (MYR 10k) might be justifiable. I understand others in similar roles haven’t received this, so I’d respectfully ask how my case differs, based on criteria or metrics, while maintaining confidentiality.
	3.	Future Growth and Performance:Since I’m working on my next role, I’d love to discuss a career development plan and timelines for growth. I’d also appreciate feedback on my contributions to the TWSSOPS project, activity module, and other efforts, including how these might be recognized or supported.
	4.	Bonuses and Workload:Could we discuss the structure of bonuses or long-term incentives tied to my salary? I’m also managing significant responsibilities alone, so I’d kindly ask about potential support or resources.

I’m committed to aligning with the bank’s goals and look forward to our discussion. Please let me know if I can prepare anything else or adjust the timing. Thank you for your time and support

Dear Sahil,

I hope you’re doing well. Thank you for scheduling our call tomorrow to discuss my 2024 Year-End Review and for your recent email. I truly appreciate your leadership and the opportunity to review my performance and compensation.

To prepare effectively, I’d be grateful for your guidance on a few points:

	1.	Current Compensation and Market Positioning:You mentioned my salary of 127,650 MYR is 27.66% above the market median for Band 7, and I was hired above market median, but I haven’t received an increase in two years. I’m concerned this trend might continue, risking alignment with industry benchmarks. Could you kindly share the market data or criteria used to determine this positioning?
	2.	Potential 30% Increase (MYR 10k):Thank you for suggesting a 30% increase (MYR 10k) might be justifiable. I understand others in similar roles haven’t received this, so I’d respectfully ask how my case differs, based on criteria or metrics, while maintaining confidentiality.
	3.	Future Growth and Performance:Since I’m working on my next role, I’d love to discuss a career development plan and timelines for growth. I’d also appreciate feedback on my contributions to the TWSSOPS project, activity module, and other efforts, including how these might be recognized or supported.
	4.	Bonuses and Workload:Could we discuss the structure of bonuses or long-term incentives tied to my salary? I’m also managing significant responsibilities alone, so I’d kindly ask about potential support or resources.

I’m committed to aligning with the bank’s goals and look forward to our discussion. Please let me know if I can prepare anything else or adjust the timing. Thank you for your time and support


Dear Sahil,

I hope this message finds you well. I want to sincerely thank you for arranging our call tomorrow to discuss my 2024 Year-End Review and for the thoughtful insights you shared in your recent email. I truly value your leadership and the opportunity to review my performance and compensation with you.

To ensure I’m fully prepared and aligned with the bank’s goals, I’d greatly appreciate your guidance on a few points before our discussion. I’ve outlined my questions below, and I’m eager to hear your perspective on each:

	1.	Current Compensation and Market Positioning:You mentioned that my current salary of 127,650 MYR is 27.66% above the market median for my band (Band 7). I understand I was hired at a rate above the market median, but I’ve noticed I haven’t received a salary increase over the past two years. I’m concerned that this trend might continue into next year, potentially impacting my compensation relative to industry benchmarks. I’d love to better understand how my current compensation aligns with industry standards today and whether there’s any risk of falling below the market median in the future. Could you kindly share more about the market data or criteria used to determine this positioning? I’m eager to ensure I have a complete picture and would greatly appreciate your guidance on this.
	2.	Potential 30% Increase (MYR 10k):Thank you for noting that a 30% increase (MYR 10k) might be justifiable for my position—I’m deeply grateful for your consideration. However, I understand that others in similar roles or bands haven’t received increases of this magnitude. I’d respectfully like to ask how you arrived at this figure for me and what specific criteria, performance metrics, or market data distinguish my case from theirs, while maintaining confidentiality. If there are lower parameters or alternative considerations, I’d be thankful for your transparency on those as well.
	3.	Future Growth and Career Development:Since you mentioned I’m already working on what could be my next role, I’d kindly like to discuss my long-term growth within the bank. Could we explore a potential career development plan, including timelines for promotions or role changes, and the skills or achievements I should focus on? I’m committed to growing here and would value your advice on how I can best prepare for advancement.
	4.	Performance Feedback and Recognition of Efforts:I’m very thankful for the opportunity to contribute to the TWSSOPS project (contributing over 6 FTEs), maintain the activity module single-handedly, and support other initiatives, often working nights, weekends, and even while facing personal challenges like surgery due to prolonged sitting. I’d be grateful if we could discuss detailed feedback on my performance this year, particularly in these areas. Additionally, I’d appreciate your guidance on how these efforts might be reflected in my compensation, recognition, or support moving forward. I truly value being part of the team and want to ensure I’m on the right path.
	5.	Bonuses, Long-Term Incentives, and Workload Support:You noted that my bonus is tied to my salary, and I’d kindly like to ask if we could discuss the structure of bonuses or any long-term incentive plans that apply to my role. I’m also managing significant responsibilities on my own, and I’d respectfully inquire if there are opportunities to explore additional support or resources to ensure I can continue delivering high-quality work sustainably. I’d be grateful for your insights on these points.

I’m committed to aligning my efforts with the bank’s objectives and growing professionally, and I’m looking forward to our discussion. Please let me know if there’s anything else I can prepare for our call, and I’m more than happy to adjust the timing if needed. I truly appreciate your time, expertise, and support.


Subject: Project Status Update

Dear [Recipient’s Name],

Current project updates:
	•	SSOPS SR manual case creation is in progress, and data is populating on the View Case screen.
	•	Arul is working on Email SR creation.
	•	Sugan is handling the Transfer Screen.
	•	Suriya is being enabled to work on View Case along with me.
	•	I am working on Compose Email and integrating all components together.
	•	Supporting the team to ensure everyone has end-to-end awareness.
	•	SSOPS story in Yoda is still pending.

Best regards,
[Your Name]

import java.util.*;
import java.util.stream.Collectors;

class Person {
    String name;
    int sum;

    public Person(String name, int sum) {
        this.name = name;
        this.sum = sum;
    }

    public String getName() {
        return name;
    }

    public int getSum() {
        return sum;
    }
}

public class Main {
    public static void main(String[] args) {
        // List of Person objects
        List<Person> people = Arrays.asList(
            new Person("Akash", 198),
            new Person("Sharma", 198),
            new Person("Akash", 98)
        );

        // List of names to filter
        List<String> filterNames = Arrays.asList("Akash");

        // Filter and sum the "sum" field for each name
        Map<String, Integer> result = people.stream()
            .filter(person -> filterNames.contains(person.getName())) // Filter by names
            .collect(Collectors.groupingBy(
                Person::getName, 
                Collectors.summingInt(Person::getSum) // Sum values
            ));

        // Print result
        System.out.println(result); // Output: {Akash=296}
    }
}
BigDecimal sum
        List<Person> people = Arrays.asList(
            new Person("Akash", new BigDecimal("198.50")),
            new Person("Sharma", new BigDecimal("198.75")),
            new Person("Akash", new BigDecimal("98.25"))
        );

        // List of ABC objects with only names
        List<ABC> test = Arrays.asList(
            new ABC("Akash", BigDecimal.ZERO),  // Amount will be computed later
            new ABC("Sharma", BigDecimal.ZERO)
        );

        // Compute the sum of "sum" values for each name using BigDecimal
        Map<String, BigDecimal> sumByName = people.stream()
            .collect(Collectors.groupingBy(
                Person::getName,
                Collectors.reducing(BigDecimal.ZERO, Person::getSum, BigDecimal::add) // Summing BigDecimal values
            ));

        // Populate the amount field in ABC using the computed sum values
        List<ABC> updatedTest = test.stream()
            .map(abc -> new ABC(abc.name, sumByName.getOrDefault(abc.name, BigDecimal.ZERO)))
            .collect(Collectors.toList());

        // Print the updated list
        System.out.println(updatedTest);
    }
}

Please find attached the sheet listing the completed stories. At a high level, SR case creation, resolution, cancellation, right panel, and email composition are working in SIT for SSOPS. However, the story is not fully completed yet—we are currently testing some enabled functionalities outside the story. We will provide an update once they are finalized.

const people = [
    { age: 25, name: "Alice", level: "Medium", country: "USA" },
    { name: "Bob", age: 30, level: "Low", country: "Canada" },
    { level: "High", name: "Charlie", country: "UK", age: 35 }
];

const nameOrder = ["Bob", "Charlie", "Alice"]; // Define custom priority order

people.sort((a, b) => {
    return nameOrder.indexOf(a.name) - nameOrder.indexOf(b.name);
});

console.log(people);
task = task.taskName.toLowerCase() === 'reviewassignment';

if (reviewTask.length === 0) {
    return null;
} else {
    // Filter tasks that are completed
    const completedTask = reviewTask.filter(
        task => task.status.toLowerCase() === 'completed'
    );

    if (completedTask.length > 0) {
        // Find the task with the latest completion time
        const latestCompleteTask = completedTask.reduce((latest, task) => {
            // Validate task.enqueueTime and convert to UTC
            const taskCompletionTime = convertToUTC(task.enqueueTime);

            // If taskCompletionTime is invalid, skip this task by returning the current latest
            if (isNaN(taskCompletionTime.getTime())) {
                return latest;
            }

            // Ensure latest is a Date object
            const latestDate = latest instanceof Date ? latest : new Date(0);

            // Compare and return the later date
            return taskCompletionTime > latestDate ? taskCompletionTime : latestDate;
        }, new Date(0)); // Initialize with Unix epoch

        // If latestCompleteTask is still the initial value, no valid dates were found
        if (latestCompleteTask.getTime() === new Date(0).getTime()) {
            return new Date(0); // Or handle as needed
        }

        return latestCompleteTask;
    } else {
        return true;
    }
}

// If no tasks are 'Completed' or 'In Progress'
return null;
function convertToUTC(dateInput) {
    // If dateInput is already a Date object, use it directly
    if (dateInput instanceof Date) {
        return new Date(Date.UTC(
            dateInput.getUTCFullYear(),
            dateInput.getUTCMonth(),
            dateInput.getUTCDate(),
            dateInput.getUTCHours(),
            dateInput.getUTCMinutes(),
            dateInput.getUTCSeconds()
        ));
    }

    // Otherwise, try to parse the dateInput as a string
    const parsedDate = new Date(dateInput);
    if (isNaN(parsedDate.getTime())) {
        // If parsing fails, return a default date (Unix epoch)
        return new Date(0);
    }

    // Convert to UTC
    return new Date(Date.UTC(
        parsedDate.getUTCFullYear(),
        parsedDate.getUTCMonth(),
        parsedDate.getUTCDate(),
        parsedDate.getUTCHours(),
        parsedDate.getUTCMinutes(),
        parsedDate.getUTCSeconds()
    ));
}


function parseCustomDate(dateString) {
    // Example input: "07-Mar-25 01.16.08 PM"
    const [datePart, timePart, period] = dateString.split(" "); // Split into "07-Mar-25", "01.16.08", "PM"
    const [day, month, year] = datePart.split("-"); // Split date into "07", "Mar", "25"
    const [hours, minutes, seconds] = timePart.split("."); // Split time into "01", "16", "08"

    // Map month abbreviations to numbers (0-11 for JavaScript Date)
    const monthMap = {
        "Jan": 0, "Feb": 1, "Mar": 2, "Apr": 3, "May": 4, "Jun": 5,
        "Jul": 6, "Aug": 7, "Sep": 8, "Oct": 9, "Nov": 10, "Dec": 11
    };

    // Convert to 24-hour format
    let hourNum = parseInt(hours, 10);
    if (period === "PM" && hourNum !== 12) {
        hourNum += 12;
    } else if (period === "AM" && hourNum === 12) {
        hourNum = 0;
    }

    // Assume year "25" means 2025
    const fullYear = parseInt(year, 10) < 100 ? 2000 + parseInt(year, 10) : parseInt(year, 10);

    // Create a Date object
    const parsedDate = new Date(fullYear, monthMap[month], parseInt(day, 10), hourNum, parseInt(minutes, 10), parseInt(seconds, 10));

    // Return the Date object, or a default if invalid
    return isNaN(parsedDate.getTime()) ? new Date(0) : parsedDate;
}
const data = ["as", "ab", "h", "z", "r", "a", "s"];
const moveToEnd = ["ab", "h", "z", "r"]; // Change this to any four elements

data.sort((a, b) => {
  if (moveToEnd.includes(a) && moveToEnd.includes(b)) return 0; // Maintain their relative order
  if (moveToEnd.includes(a)) return 1;  // Move `a` to the end
  if (moveToEnd.includes(b)) return -1; // Keep other elements before them
  return a.localeCompare(b); // Sort alphabetically
});

console.log(data); // Output: ["a", "as", "s", "ab", "h", "z", "r"]

const moveToEnd = ['ab', 'h', 'z', 'r']; // Elements to move to the end

this.workbasketListParentChildData.sort((a, b) => {
  const aValue = a.workbasket || ''; // Default to empty string if undefined/null
  const bValue = b.workbasket || ''; 

  if (moveToEnd.includes(aValue) && moveToEnd.includes(bValue)) return 0; // Maintain order
  if (moveToEnd.includes(aValue)) return 1; // Move `a` to the end
  if (moveToEnd.includes(bValue)) return -1; // Move `b` before `a`
  
  return aValue.localeCompare(bValue); // Sort alphabetically (handles empty values)
});
const moveToEnd = ['ab', 'h', 'z', 'r']; // Fixed order for the last items

this.workbasketListParentChildData.sort((a, b) => {
  const aValue = a.workbasket || ''; // Handle missing values
  const bValue = b.workbasket || '';

  const aIndex = moveToEnd.indexOf(aValue);
  const bIndex = moveToEnd.indexOf(bValue);

  if (aIndex !== -1 && bIndex !== -1) {
    return aIndex - bIndex; // Maintain sequence in moveToEnd
  }
  if (aIndex !== -1) return 1; // Move `a` to the end
  if (bIndex !== -1) return -1; // Move `b` before `a`
  
  return aValue.localeCompare(bValue); // Sort the rest alphabetically
});

// Sorting Logic: Move "complete" items to the end
items.sort((a, b) => {
    if (a.status === "complete" && b.status !== "complete") return 1;
    if (a.status !== "complete" && b.status === "complete") return -1;
    return 0; // Keep other statuses in original order
});

console.
Below is the optimized version of the retrieveActivityData method with detailed code comments explaining each step. This version incorporates parallel execution, potential caching, optimized database queries, and improved error handling. Note that some parts (e.g., specific database query optimization or external API details) depend on your actual database schema and API implementation, so you may need to adjust accordingly.
package com.sc.ccs.service.activity;

import com.sc.ccs.model.ActivityCase;
import com.sc.ccs.model.ActivityLinkDetails;
import com.sc.ccs.model.AtomCaseReference;
import com.sc.ccs.model.ComplaintRequest;
import com.sc.ccs.model.EmailRecord;
import com.sc.ccs.model.IncomingEmail;
import com.sc.ccs.service.ActivityCaseService;
import com.sc.ccs.service.AtomCaseService;
import com.sc.ccs.service.EmailService;
import com.sc.ccs.service.client.ComplaintClient;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;

import javax.ws.rs.WebApplicationException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

import static com.sc.ccs.util.LogUtil.logUtil;
import static com.sc.ccs.util.LogType.APPLICATION;
import static com.sc.ccs.util.LogLevel.INFO;
import static com.sc.ccs.util.LogLevel.ERROR;

@Slf4j
public class ActivityLoggerService {

    private final ActivityCaseService activityCaseService;
    private final AtomCaseService atomCaseService;
    private final EmailService emailService;
    private final ComplaintClient complaintClient;
    private final String host;
    private final String content_type;
    private final String cpqlQuery;
    private final String srCpqlQuery;

    public ActivityLoggerService(ActivityCaseService activityCaseService,
                                 AtomCaseService atomCaseService,
                                 EmailService emailService,
                                 ComplaintClient complaintClient,
                                 String host,
                                 String content_type,
                                 String cpqlQuery,
                                 String srCpqlQuery) {
        this.activityCaseService = activityCaseService;
        this.atomCaseService = atomCaseService;
        this.emailService = emailService;
        this.complaintClient = complaintClient;
        this.host = host;
        this.content_type = content_type;
        this.cpqlQuery = cpqlQuery;
        this.srCpqlQuery = srCpqlQuery;
    }

    /**
     * Retrieves activity data for a given case ID, including related atom case references,
     * linked cases, emails, and complaint details. Optimized for parallel execution and
     * potential caching.
     *
     * @param caseId The case ID to retrieve data for
     * @return ActivitySearchResponse containing all retrieved data
     * @throws WebApplicationException if the caseId is invalid or an error occurs
     */
    public ActivitySearchResponse retrieveActivityData(String caseId) {
        // Validate the input caseId to ensure it is not null or empty
        if (StringUtils.isEmpty(caseId)) {
            throw new WebApplicationException("caseId cannot be null or empty");
        }

        try {
            // Start timing for performance monitoring
            long startTime = System.currentTimeMillis();

            // Execute independent data fetches in parallel using CompletableFuture
            CompletableFuture> activityFuture = CompletableFuture.supplyAsync(() ->
                activityCaseService.getActivityByCaseId(caseId)
            );
            CompletableFuture> atomFuture = CompletableFuture.supplyAsync(() ->
                atomCaseService.findByCaseId(caseId)
            );
            CompletableFuture> emailFuture = CompletableFuture.supplyAsync(() ->
                emailService.findEmailByCaseId(caseId)
            );
            CompletableFuture> linkFuture = CompletableFuture.supplyAsync(() ->
                new ArrayList<>(cpqlQuery, ActivityLinkDetails.class).getResultList()
            );

            // Wait for all asynchronous tasks to complete
            CompletableFuture.allOf(activityFuture, atomFuture, emailFuture, linkFuture).join();

            // Retrieve results from futures
            List activityCase = activityFuture.get();
            List atomDetails = atomFuture.get();
            List emailRecordData = emailFuture.get();
            List cpLinkIdDetails = linkFuture.get();

            // Log time taken for database queries
            logUtil.log(APPLICATION, INFO, "Database queries completed in " +
                (System.currentTimeMillis() - startTime) + "ms", null, null);

            // Extract case IDs for complaint data fetch (convert to lowercase for consistency)
            List caseInLowerCase = cpLinkIdDetails.stream()
                .map(ActivityLinkDetails::getCaseId)
                .filter(Objects::nonNull)
                .map(String::toLowerCase)
                .collect(Collectors.toList());

            // Fetch complaint data asynchronously if there are case IDs to process
            List complaintRequests = Collections.emptyList();
            if (!caseInLowerCase.isEmpty()) {
                // Use caching if complaint data is static (e.g., with @Cacheable)
                complaintRequests = complaintClient.getComplaintReqListByCaseIds(caseInLowerCase, host, content_type);
            }

            // Log time taken for API call
            logUtil.log(APPLICATION, INFO, "Complaint API call completed in " +
                (System.currentTimeMillis() - startTime) + "ms", null, null);

            // Map email records to IncomingEmail objects (avoid stream overhead for small datasets)
            List incomingEmailList = new ArrayList<>();
            for (EmailRecord email : emailRecordData) {
                incomingEmailList.add(new IncomingEmail(email.stream(), email.getId().toString(), caseId));
            }

            // Map complaint requests to ActivityLinkDetails
            ActivityLinkDetails activityLinkDetails = new ActivityLinkDetails();
            for (ActivityLinkDetails linkDetails : cpLinkIdDetails) {
                ComplaintRequest complaintRequest = complaintRequests.stream()
                    .filter(req -> linkDetails.getLinkedCaseId().equalsIgnoreCase(req.caseNumberToExtraInfo().getLinkedCaseId()))
                    .findFirst()
                    .orElse(null);
                if (complaintRequest != null) {
                    activityLinkDetails.setGroupName(complaintRequest.groupName());
                    activityLinkDetails.setCountryCode(complaintRequest.country());
                    activityLinkDetails.setClientName(complaintRequest.clientName());
                    activityLinkDetails.setStatus(complaintRequest.status());
                }
            }

            // Build the response object
            ActivitySearchResponse.Builder builder = ActivitySearchResponse.builder();
            builder.activityCase(activityCase)
                   .srDetails(Optional.ofNullable(activityLinkDetails.createQuery(srCpqlQuery, ActivityLinkDetails.class)
                       .getResultList()).orElse(Collections.emptyList()))
                   .aCDetails(Optional.ofNullable(activityLinkDetails).orElse(Collections.emptyList()));

            // Log completion and total execution time
            long endTime = System.currentTimeMillis();
            logUtil.log(APPLICATION, INFO, "Retrieve Activity Data method completed in " +
                (endTime - startTime) + "ms", null, null);

            return builder.build();

        } catch (Exception e) {
            // Log the error with detailed information
            logUtil.log(APPLICATION, ERROR, "Retrieve Activity Data method failed: " + e.getMessage(),
                null, null);
            throw new WebApplicationException("Failed to retrieve activity data", e);
        }
    }
}

/**
 * Builder class for ActivitySearchResponse (assumed to exist)
 */
class ActivitySearchResponse {
    private List activityCase;
    private List srDetails;
    private List aCDetails;

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private List activityCase = new ArrayList<>();
        private List srDetails = new ArrayList<>();
        private List aCDetails = new ArrayList<>();

        public Builder activityCase(List activityCase) {
            this.activityCase = activityCase;
            return this;
        }

        public Builder srDetails(List srDetails) {
            this.srDetails = srDetails;
            return this;
        }

        public Builder aCDetails(List aCDetails) {
            this.aCDetails = aCDetails;
            return this;
        }

        public ActivitySearchResponse build() {
            ActivitySearchResponse response = new ActivitySearchResponse();
            response.activityCase = this.activityCase;
            response.srDetails = this.srDetails;
            response.aCDetails = this.aCDetails;
            return response;
        }
    }
}
Key Optimizations and Comments
	1	Parallel Execution:
	◦	Uses CompletableFuture to run database queries (activityFuture, atomFuture, emailFuture, linkFuture) concurrently, reducing the total wait time to the longest individual query.
	◦	Comments explain the purpose of each future.
	2	Performance Monitoring:
	◦	Adds timing logs at key stages (database queries, API call, method completion) to help profile performance.
	◦	Comments highlight the intent of timing logs.
	3	Database Query Optimization:
	◦	The code assumes that cpqlQuery and srCpqlQuery are pre-optimized. You should ensure these queries use indexes on caseId and other join columns.
	◦	Comments suggest combining queries with JOINs if possible (to be implemented based on your schema).
	4	External API Optimization:
	◦	Includes a placeholder for caching with @Cacheable (e.g., using Spring Cache). You can add this annotation if using a caching framework.
	◦	Comments suggest batching or asynchronous calls if the API is slow.
	5	Stream Optimization:
	◦	Replaces stream operations for email mapping with a traditional loop to avoid overhead for small datasets.
	◦	Comments note the trade-off and suggest parallelStream() for large datasets.
	6	Error Handling:
	◦	Enhanced exception handling with detailed logging and rethrowing as WebApplicationException.
	◦	Comments explain the purpose of each catch block.
	7	Code Structure:
	◦	Added a simple ActivitySearchResponse.Builder class for clarity (assumed to exist in your codebase; adjust as needed).
	◦	Comments document the purpose of each method and parameter.
Additional Recommendations
	•	Database Indexing: Add indexes on caseId columns in the activity, atom_case_reference, link_case, and email tables.
	•	Caching Setup: Implement a caching solution (e.g., Redis or Caffeine) for complaintClient.getComplaintReqListByCaseIds.
	•	Profiling: Use a profiler (e.g., VisualVM) to measure the impact of these changes and identify remaining bottlenecks.
	•	Testing: Test the optimized code with realistic data to ensure the 7-second execution time is reduced (targeting under 1-2 seconds).
Let me know if you need help with specific implementations (e.g., caching setup, query optimization) or further refinements!


document.addEventListener("DOMContentLoaded", function () {
    let tableRows = Array.from(document.querySelectorAll("table tbody tr")); // Select all table rows

    tableRows.sort((rowA, rowB) => {
        let statusA = rowA.cells[2].innerText.trim().toLowerCase(); // Adjust the index based on actual table structure
        let statusB = rowB.cells[2].innerText.trim().toLowerCase();

        if (statusA === "completed" && statusB !== "completed") return 1;
        if (statusA !== "completed" && statusB === "completed") return -1;
        return 0;
    });

    let tbody = document.querySelector("table tbody");
    tbody.innerHTML = ""; // Clear existing rows
    tableRows.forEach(row => tbody.appendChild(row)); // Append sorted rows
});

// Sample array from the screenshot
let tasks = [
  { taskId: '158297', taskName: 'Activity', assigneeto: 'Rahul Sharma', deadline: '2025-03-13T07:30', status: 'Completed' },
  { taskId: '158299', taskName: 'Activity', assigneeto: 'Rahul Sharma', status: 'Open-PendingCompletion', deadline: '2025-03-13T07:30' },
  { taskId: '158301', taskName: 'ReviewAssignment', assigneeto: 'main wb 01', status: 'Open-PendingEmailREVIEW', deadline: '2025-03-13T07:30' }
];

// Custom sort function
tasks.sort((a, b) => {
  // If both tasks are completed or both are not completed, maintain order or sort by taskName
  if (a.status === 'Completed' && b.status === 'Completed') return 0;
  if (a.status !== 'Completed' && b.status !== 'Completed') {
    return a.taskName.localeCompare(b.taskName); // Sort non-completed tasks alphabetically by taskName
  }
  // Move completed tasks to the bottom
  return a.status === 'Completed' ? 1 : -1;
});

// Log the result
console.log(tasks);

+---------------------------+
|         API Call          |
| (User clicks assignment)  |
+------------+--------------+
             |
             v
+---------------------------+
| Check if assignment is    |
| already locked by another |
| user in WorkList/WorkBasket |
+------------+--------------+
             |
        Yes  |  No
  +----------+----------+
  |                     |
  v                     v
+-----------------------+  +---------------------------+
| Check assignment lock |  | Lock the assignment      |
| time in WorkList/    |  | Update lock flag & time  |
| WorkBasket (>30 min) |  | in WorkList, WorkBasket  |
+------------+----------+  | and Main Table          |
             |             +---------------------------+
             v
+-----------------------+
| Unlock in WorkList &  |
| WorkBasket if > 30 min|
+------------+----------+
             |
             v
+---------------------------+
| Check if all tasks        |
| are unlocked in both      |
| WorkList and WorkBasket   |
+------------+--------------+
             |
        Yes  |  No
  +----------+----------+
  |                     |
  v                     v
+-----------------------+  +----------------------------+
| Unlock Case Table     |  | Keep Case Table Locked     |
+-----------------------+  +----------------------------+


[User clicks Assignment]
        |
        v
[API Endpoint: OpenAssignment]
        |
        v
[Check Existing Locks] ----> [Any Locks Found?]
        |                           |
    No Locks                     Yes
        |                           |
        v                           v
[Lock Assignment]          [Check Lock Duration]
        |                           |
        v                           v
[Update Main Table]        [> 30 mins Inactive?]
        |                           |
        v                      Yes  |   No
[Update WorkList]              v      |
        |                  [Unlock]    |
        v                           |
[Update WorkBasket]                |
        |                           |
        v                           v
[Return Success]             [Keep Locked]


Process Description: Opening an Assignment

This process outlines what happens when a user clicks on an assignment in the system. The goal is to manage locks on tasks and cases efficiently, ensuring that only one user can work on an assignment at a time, while also handling situations where assignments have been left inactive for too long.

Step 1: User Clicks an Assignment

	•	The process begins when a user selects an assignment they want to work on. This triggers a call to the system’s “OpenAssignment” API endpoint.

Step 2: API Endpoint - OpenAssignment

	•	The system receives the request to open the assignment. It knows which case (a collection of tasks) and specific assignment (e.g., Task1, Task2, or Task3) the user wants, along with the user’s identity.

Step 3: Check for Existing Locks

	•	The system first checks if any tasks related to the same case are already locked by another user. A “lock” means someone else is currently working on a task, and the system tracks this in two places: the WorkList table (personal task list) and the WorkBasket table (shared task pool).

Step 4: Are There Any Locks Found?

	•	The system evaluates the results of the lock check:
	•	No Locks Found: If no other user has locked any tasks for this case, the system moves forward to lock the assignment for the current user.
	•	Locks Found: If another user has locked one or more tasks, the system needs to investigate further.

Path A: No Locks Found

	•	Step 5A: Lock the Assignment
	•	Since no one else is working on tasks for this case, the system locks the selected assignment for the current user. This ensures no one else can take it while the user is working.
	•	Step 6A: Update the Main Table
	•	The system updates the Case Table (the main record for the case) to show that the case is now locked by the current user, along with the current time.
	•	Step 7A: Update WorkList
	•	The system marks the assignment as locked in the WorkList table, recording the user and timestamp.
	•	Step 8A: Update WorkBasket
	•	Similarly, the assignment is marked as locked in the WorkBasket table with the same details.
	•	Step 9A: Return Success
	•	The system confirms to the user that the assignment is now open and locked for them to work on.

Path B: Locks Found

	•	Step 5B: Check Lock Duration
	•	For each locked task found, the system calculates how long it has been locked by comparing the lock timestamp to the current time.
	•	Step 6B: Is It Inactive for More Than 30 Minutes?
	•	The system checks if the lock has been inactive for over 30 minutes:
	•	Yes (Inactive > 30 Minutes):
	•	Step 7B: Unlock the Task
	•	If a task has been locked for more than 30 minutes, the system assumes the other user is no longer active. It unlocks the task by clearing the lock details in both the WorkList and WorkBasket tables.
	•	The process then loops back to check if any other locks remain (Step 3). If all tasks are unlocked, it follows Path A to lock the new assignment.
	•	No (Inactive ≤ 30 Minutes):
	•	Step 8B: Keep Locked
	•	If any task is still actively locked (less than or equal to 30 minutes), the system keeps the case locked to prevent conflicts. It stops the process here and informs the user that the case remains locked due to another active user.

Final Outcome

	•	Success: If no active locks remain (either none existed or all were inactive and unlocked), the assignment is locked for the user, and they can start working.
	•	Locked: If any task is still actively locked by another user, the system keeps the case locked and tells the user they can’t proceed yet.

Key Points to Understand

	•	Why Locks Matter: Locks prevent multiple users from working on the same tasks at once, avoiding confusion or duplicated effort.
	•	30-Minute Rule: If a task is locked but inactive for over 30 minutes, the system assumes the user has abandoned it and frees it up for others.
	•	Tables Involved:
	•	Case Table: Tracks the overall case status (locked or not).
	•	WorkList Table: Manages personal task assignments.
	•	WorkBasket Table: Manages shared task assignments.
	•	Consistency: The system updates all three tables to keep everything in sync.


package com.example.service;

import com.example.entity.ActivityCase;
import com.example.entity.WorkBasket;
import com.example.entity.WorkList;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import jakarta.transaction.Transactional;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

@ApplicationScoped
public class AssignmentService {

    @Inject
    EntityManager entityManager;

    @Transactional
    public String openAssignment(Long caseId, Long taskId, String userId) {
        // Step 1: User clicks an assignment (via API endpoint)

        // Step 2: Find the task in WorkList and WorkBasket in parallel
        CompletableFuture<WorkList> workListFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createQuery(
                    "SELECT wl FROM WorkList wl WHERE wl.caseId = :caseId AND wl.taskId = :taskId");
            query.setParameter("caseId", caseId);
            query.setParameter("taskId", taskId);
            List<WorkList> result = query.getResultList();
            return result.isEmpty() ? null : result.get(0);
        });

        CompletableFuture<WorkBasket> workBasketFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createQuery(
                    "SELECT wb FROM WorkBasket wb WHERE wb.caseId = :caseId AND wb.taskId = :taskId");
            query.setParameter("caseId", caseId);
            query.setParameter("taskId", taskId);
            List<WorkBasket> result = query.getResultList();
            return result.isEmpty() ? null : result.get(0);
        });

        // Combine results
        WorkList workListTask = workListFuture.join();
        WorkBasket workBasketTask = workBasketFuture.join();

        if (workListTask == null && workBasketTask == null) {
            return "Task not found in WorkList or WorkBasket for caseId: " + caseId;
        }

        // Step 2: Get the ActivityCase
        Query caseQuery = entityManager.createQuery(
                "SELECT ac FROM ActivityCase ac WHERE ac.caseId = :caseId", ActivityCase.class);
        caseQuery.setParameter("caseId", caseId);
        ActivityCase activityCase = (ActivityCase) caseQuery.getSingleResult();
        if (activityCase == null) {
            return "Case not found for caseId: " + caseId;
        }

        // Step 3: Check for existing locks in parallel
        CompletableFuture<List<WorkList>> workListLocksFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createQuery(
                    "SELECT wl FROM WorkList wl WHERE wl.caseId = :caseId AND wl.lockedBy IS NOT NULL AND wl.lockedBy != :userId");
            query.setParameter("caseId", caseId);
            query.setParameter("userId", userId);
            return query.getResultList();
        });

        CompletableFuture<List<WorkBasket>> workBasketLocksFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createQuery(
                    "SELECT wb FROM WorkBasket wb WHERE wb.caseId = :caseId AND wb.lockedBy IS NOT NULL AND wb.lockedBy != :userId");
            query.setParameter("caseId", caseId);
            query.setParameter("userId", userId);
            return query.getResultList();
        });

        // Combine lock check results
        List<WorkList> lockedWorkListTasks = workListLocksFuture.join();
        List<WorkBasket> lockedWorkBasketTasks = workBasketLocksFuture.join();
        AtomicBoolean hasActiveLocks = new AtomicBoolean(false);

        lockedWorkListTasks.forEach(task -> {
            if (isTaskStillActive(task.getLockedOn())) {
                hasActiveLocks.set(true);
            }
        });

        lockedWorkBasketTasks.forEach(task -> {
            if (isTaskStillActive(task.getLockedOn())) {
                hasActiveLocks.set(true);
            }
        });

        if (hasActiveLocks.get()) {
            // Step 4: Locks found, proceed to Path B
            return handleLocksFound(caseId, userId);
        }

        // Path A: No active locks found
        return lockAssignment(activityCase, workListTask, workBasketTask, userId);
    }

    private boolean isTaskStillActive(LocalDateTime lockedOn) {
        if (lockedOn == null) {
            return false;
        }
        Duration duration = Duration.between(lockedOn, LocalDateTime.now());
        return duration.toMinutes() <= 30;
    }

    private String handleLocksFound(Long caseId, String userId) {
        // Step 5B: Check lock duration for all tasks
        AtomicBoolean allInactive = new AtomicBoolean(true);
        AtomicReference<String> lockedBy = new AtomicReference<>();

        // Fetch all tasks in parallel
        CompletableFuture<List<WorkList>> workListTasksFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createQuery(
                    "SELECT wl FROM WorkList wl WHERE wl.caseId = :caseId", WorkList.class);
            query.setParameter("caseId", caseId);
            return query.getResultList();
        });

        CompletableFuture<List<WorkBasket>> workBasketTasksFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createQuery(
                    "SELECT wb FROM WorkBasket wb WHERE wb.caseId = :caseId", WorkBasket.class);
            query.setParameter("caseId", caseId);
            return query.getResultList();
        });

        // Combine results
        List<WorkList> workListTasks = workListTasksFuture.join();
        List<WorkBasket> workBasketTasks = workBasketTasksFuture.join();

        // Check WorkList tasks
        workListTasks.forEach(task -> {
            if (task.getLockedBy() != null && !task.getLockedBy().equals(userId)) {
                if (isTaskStillActive(task.getLockedOn())) {
                    allInactive.set(false);
                    lockedBy.set(task.getLockedBy());
                } else {
                    // Step 7B: Unlock inactive task
                    task.setLockedBy(null);
                    task.setLockedOn(null);
                    entityManager.merge(task);
                }
            }
        });

        // Check WorkBasket tasks
        workBasketTasks.forEach(task -> {
            if (task.getLockedBy() != null && !task.getLockedBy().equals(userId)) {
                if (isTaskStillActive(task.getLockedOn())) {
                    allInactive.set(false);
                    lockedBy.set(task.getLockedBy());
                } else {
                    // Step 7B: Unlock inactive task
                    task.setLockedBy(null);
                    task.setLockedOn(null);
                    entityManager.merge(task);
                }
            }
        });

        if (!allInactive.get()) {
            // Step 8B: Keep locked
            return "Case is locked by " + lockedBy.get() + ". Try again later.";
        }

        // All locks were inactive and cleared, proceed to lock for current user
        Query caseQuery = entityManager.createQuery(
                "SELECT ac FROM ActivityCase ac WHERE ac.caseId = :caseId", ActivityCase.class);
        caseQuery.setParameter("caseId", caseId);
        ActivityCase activityCase = (ActivityCase) caseQuery.getSingleResult();
        return lockAssignment(activityCase, null, null, userId);
    }

    private String lockAssignment(ActivityCase activityCase, WorkList workListTask, WorkBasket workBasketTask, String userId) {
        LocalDateTime now = LocalDateTime.now();

        // Step 5A & 6A: Lock the case
        activityCase.setLockedStatus("LOCKED");
        activityCase.setLockedBy(userId);
        activityCase.setLockedOpname("OpenAssignment");
        activityCase.setLockedOn(now);
        entityManager.merge(activityCase);

        // Step 7A & 8A: Update the task in WorkList or WorkBasket
        if (workListTask != null) {
            workListTask.setLockedBy(userId);
            workListTask.setLockedOn(now);
            entityManager.merge(workListTask);
        } else if (workBasketTask != null) {
            workBasketTask.setLockedBy(userId);
            workBasketTask.setLockedOn(now);
            entityManager.merge(workBasketTask);
        }

        // Step 9A: Return success
        return "Task locked successfully for user " + userId;
    }
}

Query query = entityManager.createNativeQuery(
                    "SELECT * FROM work_list WHERE case_id = :caseId AND CAST(JSON_VALUE(flow_type, '$.id') AS BIGINT) = :taskId", WorkList.class);
            query.setParameter("caseId", caseId);
            query.setParameter("taskId", inputTaskId);
            List<WorkList> result = query.getResultList();
            return result.isEmpty() ? null : result.get(0);
        });

package com.example.service;

import com.example.entity.ActivityCase;
import com.example.entity.WorkBasket;
import com.example.entity.WorkList;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import jakarta.transaction.Transactional;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

@ApplicationScoped
public class AssignmentService {

    @Inject
    EntityManager entityManager;

    @Transactional
    public String openAssignment(Long caseId, Long inputTaskId, String userId) {
        // Convert numeric caseId to the expected string format (adjust format as per your data)
        String caseIdStr = "AC-ZZ-" + String.format("%010d", caseId); // Example format: AC-ZZ-20250312-M00622

        // Step 2: Find the task in WorkList (asign_wl) and WorkBasket (asign_wb) in parallel
        CompletableFuture<WorkList> workListFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createNativeQuery(
                    "SELECT * FROM client_srvc.asign_wl WHERE case_id = :caseId AND CAST((flowtype::JSONB->0->>'id') AS BIGINT) = :taskId", WorkList.class);
            query.setParameter("caseId", caseIdStr);
            query.setParameter("taskId", inputTaskId);
            List<WorkList> result = query.getResultList();
            return result.isEmpty() ? null : result.get(0);
        });

        CompletableFuture<WorkBasket> workBasketFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createNativeQuery(
                    "SELECT * FROM client_srvc.asign_wb WHERE case_id = :caseId AND CAST((flowtype::JSONB->0->>'id') AS BIGINT) = :taskId", WorkBasket.class);
            query.setParameter("caseId", caseIdStr);
            query.setParameter("taskId", inputTaskId);
            List<WorkBasket> result = query.getResultList();
            return result.isEmpty() ? null : result.get(0);
        });

        // Combine results
        WorkList workListTask = workListFuture.join();
        WorkBasket workBasketTask = workBasketFuture.join();

        if (workListTask == null && workBasketTask == null) {
            return "Task not found in WorkList or WorkBasket for caseId: " + caseIdStr + " and taskId: " + inputTaskId;
        }

        // Step 2: Get the ActivityCase (using numeric caseId)
        Query caseQuery = entityManager.createQuery(
                "SELECT ac FROM ActivityCase ac WHERE ac.caseId = :caseId", ActivityCase.class);
        caseQuery.setParameter("caseId", caseId);
        ActivityCase activityCase = (ActivityCase) caseQuery.getSingleResult();
        if (activityCase == null) {
            return "Case not found for caseId: " + caseId;
        }

        // Step 3: Check for existing locks in parallel
        CompletableFuture<List<WorkList>> workListLocksFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createNativeQuery(
                    "SELECT * FROM client_srvc.asign_wl WHERE case_id = :caseId AND locked_by IS NOT NULL AND locked_by != :userId", WorkList.class);
            query.setParameter("caseId", caseIdStr);
            query.setParameter("userId", userId);
            return query.getResultList();
        });

        CompletableFuture<List<WorkBasket>> workBasketLocksFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createNativeQuery(
                    "SELECT * FROM client_srvc.asign_wb WHERE case_id = :caseId AND locked_by IS NOT NULL AND locked_by != :userId", WorkBasket.class);
            query.setParameter("caseId", caseIdStr);
            query.setParameter("userId", userId);
            return query.getResultList();
        });

        // Combine lock check results
        List<WorkList> lockedWorkListTasks = workListLocksFuture.join();
        List<WorkBasket> lockedWorkBasketTasks = workBasketLocksFuture.join();
        AtomicBoolean hasActiveLocks = new AtomicBoolean(false);

        lockedWorkListTasks.forEach(task -> {
            if (isTaskStillActive(task.getLockedOn())) {
                hasActiveLocks.set(true);
            }
        });

        lockedWorkBasketTasks.forEach(task -> {
            if (isTaskStillActive(task.getLockedOn())) {
                hasActiveLocks.set(true);
            }
        });

        if (hasActiveLocks.get()) {
            // Step 4: Locks found, proceed to Path B
            return handleLocksFound(caseIdStr, userId);
        }

        // Path A: No active locks found
        return lockAssignment(activityCase, workListTask, workBasketTask, userId);
    }

    private boolean isTaskStillActive(LocalDateTime lockedOn) {
        if (lockedOn == null) {
            return false;
        }
        Duration duration = Duration.between(lockedOn, LocalDateTime.now());
        return duration.toMinutes() <= 30;
    }

    private String handleLocksFound(String caseId, String userId) {
        // Step 5B: Check lock duration for all tasks
        AtomicBoolean allInactive = new AtomicBoolean(true);
        AtomicReference<String> lockedBy = new AtomicReference<>();

        // Fetch all tasks in parallel
        CompletableFuture<List<WorkList>> workListTasksFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createNativeQuery(
                    "SELECT * FROM client_srvc.asign_wl WHERE case_id = :caseId", WorkList.class);
            query.setParameter("caseId", caseId);
            return query.getResultList();
        });

        CompletableFuture<List<WorkBasket>> workBasketTasksFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createNativeQuery(
                    "SELECT * FROM client_srvc.asign_wb WHERE case_id = :caseId", WorkBasket.class);
            query.setParameter("caseId", caseId);
            return query.getResultList();
        });

        // Combine results
        List<WorkList> workListTasks = workListTasksFuture.join();
        List<WorkBasket> workBasketTasks = workBasketTasksFuture.join();

        // Check WorkList tasks
        workListTasks.forEach(task -> {
            if (task.getLockedBy() != null && !task.getLockedBy().equals(userId)) {
                if (isTaskStillActive(task.getLockedOn())) {
                    allInactive.set(false);
                    lockedBy.set(task.getLockedBy());
                } else {
                    // Step 7B: Unlock inactive task
                    task.setLockedBy(null);
                    task.setLockedOn(null);
                    entityManager.merge(task);
                }
            }
        });

        // Check WorkBasket tasks
        workBasketTasks.forEach(task -> {
            if (task.getLockedBy() != null && !task.getLockedBy().equals(userId)) {
                if (isTaskStillActive(task.getLockedOn())) {
                    allInactive.set(false);
                    lockedBy.set(task.getLockedBy());
                } else {
                    // Step 7B: Unlock inactive task
                    task.setLockedBy(null);
                    task.setLockedOn(null);
                    entityManager.merge(task);
                }
            }
        });

        if (!allInactive.get()) {
            // Step 8B: Keep locked
            return "Case is locked by " + lockedBy.get() + ". Try again later.";
        }

        // All locks were inactive and cleared, proceed to lock for current user
        Query caseQuery = entityManager.createQuery(
                "SELECT ac FROM ActivityCase ac WHERE ac.caseId = :caseId", ActivityCase.class);
        caseQuery.setParameter("caseId", extractNumericCaseId(caseId)); // Convert back to numeric if needed
        ActivityCase activityCase = (ActivityCase) caseQuery.getSingleResult();
        return lockAssignment(activityCase, null, null, userId);
    }

    private String lockAssignment(ActivityCase activityCase, WorkList workListTask, WorkBasket workBasketTask, String userId) {
        LocalDateTime now = LocalDateTime.now();

        // Step 5A & 6A: Lock the case
        activityCase.setLockedStatus("LOCKED");
        activityCase.setLockedBy(userId);
        activityCase.setLockedOpname("OpenAssignment");
        activityCase.setLockedOn(now);
        entityManager.merge(activityCase);

        // Step 7A & 8A: Update the task in WorkList or WorkBasket
        if (workListTask != null) {
            workListTask.setLockedBy(userId);
            workListTask.setLockedOn(now);
            entityManager.merge(workListTask);
        } else if (workBasketTask != null) {
            workBasketTask.setLockedBy(userId);
            workBasketTask.setLockedOn(now);
            entityManager.merge(workBasketTask);
        }

        // Step 9A: Return success
        return "Task locked successfully for user " + userId;
    }

    // Helper method to extract numeric caseId from string format (if needed)
    private Long extractNumericCaseId(String caseIdStr) {
        // Example: Extract numeric part from "AC-ZZ-20250312-M00622"
        String[] parts = caseIdStr.split("-");
        if (parts.length >= 2) {
            return Long.parseLong(parts[1]); // Adjust based on your format
        }
        return null;
    }
}

package com.example.service;

import com.example.entity.ActivityCase;
import com.example.entity.WorkBasket;
import com.example.entity.WorkList;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import jakarta.transaction.Transactional;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

@ApplicationScoped
public class AssignmentService {

    @Inject
    EntityManager entityManager;

    @Transactional
    public String openAssignment(Long caseId, Long inputTaskId, String userId) {
        // Convert numeric caseId to the expected string format for WorkList/WorkBasket
        String caseIdStr = "AC-ZZ-" + String.format("%010d", caseId); // Adjust format as per your data

        // Step 2: Fetch the ActivityCase record (single query)
        Query caseQuery = entityManager.createQuery(
                "SELECT ac FROM ActivityCase ac WHERE ac.caseId = :caseId", ActivityCase.class);
        caseQuery.setParameter("caseId", caseId);
        ActivityCase activityCase = (ActivityCase) caseQuery.getSingleResult();
        if (activityCase == null) {
            return "Case not found for caseId: " + caseId;
        }

        // Step 3: Fetch tasks from WorkList and WorkBasket in parallel (single query per table)
        CompletableFuture<List<WorkList>> workListTasksFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createNativeQuery(
                    "SELECT * FROM client_srvc.asign_wl WHERE case_id = :caseId", WorkList.class);
            query.setParameter("caseId", caseIdStr);
            return query.getResultList();
        });

        CompletableFuture<List<WorkBasket>> workBasketTasksFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createNativeQuery(
                    "SELECT * FROM client_srvc.asign_wb WHERE case_id = :caseId", WorkBasket.class);
            query.setParameter("caseId", caseIdStr);
            return query.getResultList();
        });

        // Combine results
        List<WorkList> workListTasks = workListTasksFuture.join();
        List<WorkBasket> workBasketTasks = workBasketTasksFuture.join();

        // Step 4: Filter tasks by taskId in memory
        WorkList workListTask = workListTasks.stream()
                .filter(wl -> {
                    try {
                        Long taskId = Long.parseLong((wl.getFlowType() != null && !wl.getFlowType().isEmpty()
                                ? (wl.getFlowType()::JSONB->0->>'id')
                                : "0"));
                        return taskId.equals(inputTaskId);
                    } catch (Exception e) {
                        return false;
                    }
                })
                .findFirst()
                .orElse(null);

        WorkBasket workBasketTask = workBasketTasks.stream()
                .filter(wb -> {
                    try {
                        Long taskId = Long.parseLong((wb.getFlowType() != null && !wb.getFlowType().isEmpty()
                                ? (wb.getFlowType()::JSONB->0->>'id')
                                : "0"));
                        return taskId.equals(inputTaskId);
                    } catch (Exception e) {
                        return false;
                    }
                })
                .findFirst()
                .orElse(null);

        if (workListTask == null && workBasketTask == null) {
            return "Task not found in WorkList or WorkBasket for caseId: " + caseIdStr + " and taskId: " + inputTaskId;
        }

        // Step 5: Check for existing locks in memory
        AtomicBoolean hasActiveLocks = new AtomicBoolean(false);
        AtomicReference<String> lockedByRef = new AtomicReference<>();

        // Filter locked tasks in memory
        List<WorkList> lockedWorkListTasks = workListTasks.stream()
                .filter(task -> task.getLockedBy() != null && !task.getLockedBy().equals(userId))
                .collect(Collectors.toList());

        List<WorkBasket> lockedWorkBasketTasks = workBasketTasks.stream()
                .filter(task -> task.getLockedBy() != null && !task.getLockedBy().equals(userId))
                .collect(Collectors.toList());

        lockedWorkListTasks.forEach(task -> {
            if (isTaskStillActive(task.getLockedOn())) {
                hasActiveLocks.set(true);
                lockedByRef.set(task.getLockedBy());
            }
        });

        lockedWorkBasketTasks.forEach(task -> {
            if (isTaskStillActive(task.getLockedOn())) {
                hasActiveLocks.set(true);
                lockedByRef.set(task.getLockedBy());
            }
        });

        if (hasActiveLocks.get()) {
            // Step 6: Locks found, proceed to Path B
            return handleLocksFound(caseIdStr, userId, workListTasks, workBasketTasks);
        }

        // Path A: No active locks found
        return lockAssignment(activityCase, workListTask, workBasketTask, userId);
    }

    private boolean isTaskStillActive(LocalDateTime lockedOn) {
        if (lockedOn == null) {
            return false;
        }
        Duration duration = Duration.between(lockedOn, LocalDateTime.now());
        return duration.toMinutes() <= 30;
    }

    private String handleLocksFound(String caseId, String userId, List<WorkList> workListTasks, List<WorkBasket> workBasketTasks) {
        // Step 5B: Check lock duration for all tasks
        AtomicBoolean allInactive = new AtomicBoolean(true);
        AtomicReference<String> lockedBy = new AtomicReference<>();

        // Filter and check locks in memory
        workListTasks.stream()
                .filter(task -> task.getLockedBy() != null && !task.getLockedBy().equals(userId))
                .forEach(task -> {
                    if (isTaskStillActive(task.getLockedOn())) {
                        allInactive.set(false);
                        lockedBy.set(task.getLockedBy());
                    } else {
                        // Step 7B: Unlock inactive task
                        task.setLockedBy(null);
                        task.setLockedOn(null);
                        entityManager.merge(task);
                    }
                });

        workBasketTasks.stream()
                .filter(task -> task.getLockedBy() != null && !task.getLockedBy().equals(userId))
                .forEach(task -> {
                    if (isTaskStillActive(task.getLockedOn())) {
                        allInactive.set(false);
                        lockedBy.set(task.getLockedBy());
                    } else {
                        // Step 7B: Unlock inactive task
                        task.setLockedBy(null);
                        task.setLockedOn(null);
                        entityManager.merge(task);
                    }
                });

        if (!allInactive.get()) {
            // Step 8B: Keep locked
            return "Case is locked by " + lockedBy.get() + ". Try again later.";
        }

        // All locks were inactive and cleared, proceed to lock for current user
        Query caseQuery = entityManager.createQuery(
                "SELECT ac FROM ActivityCase ac WHERE ac.caseId = :caseId", ActivityCase.class);
        caseQuery.setParameter("caseId", extractNumericCaseId(caseId));
        ActivityCase activityCase = (ActivityCase) caseQuery.getSingleResult();
        return lockAssignment(activityCase, null, null, userId);
    }

    private String lockAssignment(ActivityCase activityCase, WorkList workListTask, WorkBasket workBasketTask, String userId) {
        LocalDateTime now = LocalDateTime.now();

        // Step 5A & 6A: Lock the case
        activityCase.setLockedStatus("LOCKED");
        activityCase.setLockedBy(userId);
        activityCase.setLockedOpname("OpenAssignment");
        activityCase.setLockedOn(now);
        entityManager.merge(activityCase);

        // Step 7A & 8A: Update the task in WorkList or WorkBasket
        if (workListTask != null) {
            workListTask.setLockedBy(userId);
            workListTask.setLockedOn(now);
            entityManager.merge(workListTask);
        } else if (workBasketTask != null) {
            workBasketTask.setLockedBy(userId);
            workBasketTask.setLockedOn(now);
            entityManager.merge(workBasketTask);
        }

        // Step 9A: Return success
        return "Task locked successfully for user " + userId;
    }

    // Helper method to extract numeric caseId from string format
    private Long extractNumericCaseId(String caseIdStr) {
        // Example: Extract numeric part from "AC-ZZ-20250312-M00622"
        String[] parts = caseIdStr.split("-");
        if (parts.length >= 2) {
            return Long.parseLong(parts[1].replaceAll("[^0-9]", ""));
        }
        return null;
    }
}

package com.example.service;

import com.example.entity.ActivityCase;
import com.example.entity.WorkBasket;
import com.example.entity.WorkList;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import jakarta.transaction.Transactional;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

@ApplicationScoped
public class AssignmentService {

    @Inject
    EntityManager entityManager;

    @Transactional
    public String openAssignment(Long caseId, Long inputTaskId, String userId) {
        // Convert numeric caseId to the expected string format for WorkList/WorkBasket
        String caseIdStr = "AC-ZZ-" + String.format("%010d", caseId); // Adjust format as per your data

        // Step 2: Fetch the ActivityCase record (single query)
        Query caseQuery = entityManager.createQuery(
                "SELECT ac FROM ActivityCase ac WHERE ac.caseId = :caseId", ActivityCase.class);
        caseQuery.setParameter("caseId", caseId);
        ActivityCase activityCase = (ActivityCase) caseQuery.getSingleResult();
        if (activityCase == null) {
            return "Case not found for caseId: " + caseId;
        }

        // Step 3: Fetch tasks from WorkList and WorkBasket in parallel (single query per table)
        CompletableFuture<List<WorkList>> workListTasksFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createNativeQuery(
                    "SELECT * FROM client_srvc.asign_wl WHERE case_id = :caseId", WorkList.class);
            query.setParameter("caseId", caseIdStr);
            return query.getResultList();
        });

        CompletableFuture<List<WorkBasket>> workBasketTasksFuture = CompletableFuture.supplyAsync(() -> {
            Query query = entityManager.createNativeQuery(
                    "SELECT * FROM client_srvc.asign_wb WHERE case_id = :caseId", WorkBasket.class);
            query.setParameter("caseId", caseIdStr);
            return query.getResultList();
        });

        // Combine results
        List<WorkList> workListTasks = workListTasksFuture.join();
        List<WorkBasket> workBasketTasks = workBasketTasksFuture.join();

        // Step 4: Filter tasks by taskId in memory
        WorkList workListTask = workListTasks.stream()
                .filter(wl -> {
                    try {
                        String flowType = wl.getFlowType();
                        Long taskId = (flowType != null && !flowType.isEmpty())
                                ? Long.parseLong((flowType)::JSONB->0->>'id')
                                : null;
                        return taskId != null && taskId.equals(inputTaskId);
                    } catch (Exception e) {
                        return false;
                    }
                })
                .findFirst()
                .orElse(null);

        WorkBasket workBasketTask = workBasketTasks.stream()
                .filter(wb -> {
                    try {
                        String flowType = wb.getFlowType();
                        Long taskId = (flowType != null && !flowType.isEmpty())
                                ? Long.parseLong((flowType)::JSONB->0->>'id')
                                : null;
                        return taskId != null && taskId.equals(inputTaskId);
                    } catch (Exception e) {
                        return false;
                    }
                })
                .findFirst()
                .orElse(null);

        if (workListTask == null && workBasketTask == null) {
            return "Task not found in WorkList or WorkBasket for caseId: " + caseIdStr + " and taskId: " + inputTaskId;
        }

        // Step 5: Check and unlock inactive tasks (more than 30 minutes in UTC)
        boolean allTasksUnlocked = checkAndUnlockInactiveTasks(workListTasks, workBasketTasks, userId);

        // Step 6: Update ActivityCase if all tasks are unlocked
        if (allTasksUnlocked && "LOCKED".equals(activityCase.getLockedStatus())) {
            activityCase.setLockedStatus("UNLOCKED");
            activityCase.setLockedBy(null);
            activityCase.setLockedOn(null);
            activityCase.setLockedOpname(null);
            entityManager.merge(activityCase);
        }

        // Step 7: Check for existing active locks
        AtomicBoolean hasActiveLocks = new AtomicBoolean(false);
        AtomicReference<String> lockedByRef = new AtomicReference<>();

        // Filter locked tasks in memory (excluding current user and unlocked tasks)
        List<WorkList> lockedWorkListTasks = workListTasks.stream()
                .filter(task -> task.getLockedBy() != null && !task.getLockedBy().equals(userId) && isTaskStillActive(task.getLockedOn()))
                .collect(Collectors.toList());

        List<WorkBasket> lockedWorkBasketTasks = workBasketTasks.stream()
                .filter(task -> task.getLockedBy() != null && !task.getLockedBy().equals(userId) && isTaskStillActive(task.getLockedOn()))
                .collect(Collectors.toList());

        hasActiveLocks.set(!lockedWorkListTasks.isEmpty() || !lockedWorkBasketTasks.isEmpty());
        if (hasActiveLocks.get() && !lockedWorkListTasks.isEmpty()) {
            lockedByRef.set(lockedWorkListTasks.get(0).getLockedBy());
        } else if (hasActiveLocks.get() && !lockedWorkBasketTasks.isEmpty()) {
            lockedByRef.set(lockedWorkBasketTasks.get(0).getLockedBy());
        }

        if (hasActiveLocks.get()) {
            // Step 8: Locks found, proceed to Path B
            return "Case is locked by " + lockedByRef.get() + ". Try again later.";
        }

        // Path A: No active locks found, lock the task and case
        return lockAssignment(activityCase, workListTask, workBasketTask, userId);
    }

    private boolean checkAndUnlockInactiveTasks(List<WorkList> workListTasks, List<WorkBasket> workBasketTasks, String userId) {
        boolean hasActiveLocks = false;
        LocalDateTime now = LocalDateTime.now(ZoneId.of("UTC")); // Use UTC time

        // Check and unlock WorkList tasks
        for (WorkList task : workListTasks) {
            if (task.getLockedBy() != null && !task.getLockedBy().equals(userId)) {
                if (isTaskInactiveFor30Minutes(task.getLockedOn(), now)) {
                    task.setLockedBy(null);
                    task.setLockedOn(null);
                    entityManager.merge(task);
                } else {
                    hasActiveLocks = true;
                }
            }
        }

        // Check and unlock WorkBasket tasks
        for (WorkBasket task : workBasketTasks) {
            if (task.getLockedBy() != null && !task.getLockedBy().equals(userId)) {
                if (isTaskInactiveFor30Minutes(task.getLockedOn(), now)) {
                    task.setLockedBy(null);
                    task.setLockedOn(null);
                    entityManager.merge(task);
                } else {
                    hasActiveLocks = true;
                }
            }
        }

        return !hasActiveLocks;
    }

    private boolean isTaskStillActive(LocalDateTime lockedOn) {
        if (lockedOn == null) {
            return false;
        }
        LocalDateTime now = LocalDateTime.now(ZoneId.of("UTC")); // Use UTC time
        Duration duration = Duration.between(lockedOn, now);
        return duration.toMinutes() <= 30;
    }

    private boolean isTaskInactiveFor30Minutes(LocalDateTime lockedOn, LocalDateTime now) {
        if (lockedOn == null) {
            return false;
        }
        Duration duration = Duration.between(lockedOn, now);
        return duration.toMinutes() > 30;
    }

    private String lockAssignment(ActivityCase activityCase, WorkList workListTask, WorkBasket workBasketTask, String userId) {
        LocalDateTime now = LocalDateTime.now(ZoneId.of("UTC")); // Use UTC time

        // Step 5A & 6A: Lock the case
        activityCase.setLockedStatus("LOCKED");
        activityCase.setLockedBy(userId);
        activityCase.setLockedOpname("OpenAssignment");
        activityCase.setLockedOn(now);
        entityManager.merge(activityCase);

        // Step 7A & 8A: Update the task in WorkList or WorkBasket
        if (workListTask != null) {
            workListTask.setLockedBy(userId);
            workListTask.setLockedOn(now);
            entityManager.merge(workListTask);
        } else if (workBasketTask != null) {
            workBasketTask.setLockedBy(userId);
            workBasketTask.setLockedOn(now);
            entityManager.merge(workBasketTask);
        }

        // Step 9A: Return success
        return "Task locked successfully for user " + userId;
    }

    // Helper method to extract numeric caseId from string format
    private Long extractNumericCaseId(String caseIdStr) {
        // Example: Extract numeric part from "AC-ZZ-20250312-M00622"
        String[] parts = caseIdStr.split("-");
        if (parts.length >= 2) {
            return Long.parseLong(parts[1].replaceAll("[^0-9]", ""));
        }
        return null;
    }
}

package com.example.service;

import com.example.entity.ActivityCase;
import com.example.entity.WorkBasket;
import com.example.entity.WorkList;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceException;
import jakarta.persistence.Query;
import jakarta.transaction.Transactional;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;

@ApplicationScoped
public class AssignmentService {

    @Inject
    EntityManager entityManager;

    @Transactional
    public String openAssignment(Long caseId, Long inputTaskId, String userId) {
        // Convert numeric caseId to the expected string format for WorkList/WorkBasket
        String caseIdStr = "AC-ZZ-" + String.format("%010d", caseId); // Adjust format as per your data

        // Step 2: Fetch the ActivityCase record (single query)
        ActivityCase activityCase;
        try {
            Query caseQuery = entityManager.createQuery(
                    "SELECT ac FROM ActivityCase ac WHERE ac.caseId = :caseId", ActivityCase.class);
            caseQuery.setParameter("caseId", caseId);
            activityCase = (ActivityCase) caseQuery.getSingleResult();
            if (activityCase == null) {
                return "Case not found for caseId: " + caseId;
            }
        } catch (Exception e) {
            return "Error retrieving ActivityCase: " + e.getMessage();
        }

        // Step 3: Fetch tasks from WorkList and WorkBasket in parallel with taskId filtering in SQL
        CompletableFuture<WorkList> workListTaskFuture = CompletableFuture.supplyAsync(() -> {
            try {
                Query query = entityManager.createNativeQuery(
                        "SELECT * FROM client_srvc.asign_wl WHERE case_id = :caseId AND CAST(COALESCE((flowtype::JSONB->0->>'id')::BIGINT, -1) AS BIGINT) = :taskId", WorkList.class);
                query.setParameter("caseId", caseIdStr);
                query.setParameter("taskId", inputTaskId);
                List<WorkList> result = query.getResultList();
                return result.isEmpty() ? null : result.get(0);
            } catch (PersistenceException e) {
                return null;
            }
        });

        CompletableFuture<WorkBasket> workBasketTaskFuture = CompletableFuture.supplyAsync(() -> {
            try {
                Query query = entityManager.createNativeQuery(
                        "SELECT * FROM client_srvc.asign_wb WHERE case_id = :caseId AND CAST(COALESCE((flowtype::JSONB->0->>'id')::BIGINT, -1) AS BIGINT) = :taskId", WorkBasket.class);
                query.setParameter("caseId", caseIdStr);
                query.setParameter("taskId", inputTaskId);
                List<WorkBasket> result = query.getResultList();
                return result.isEmpty() ? null : result.get(0);
            } catch (PersistenceException e) {
                return null;
            }
        });

        // Combine results with error handling
        WorkList workListTask;
        WorkBasket workBasketTask;
        try {
            workListTask = workListTaskFuture.join();
            workBasketTask = workBasketTaskFuture.join();
        } catch (Exception e) {
            return "Error retrieving tasks: " + e.getMessage();
        }

        if (workListTask == null && workBasketTask == null) {
            return "Task not found in WorkList or WorkBasket for caseId: " + caseIdStr + " and taskId: " + inputTaskId;
        }

        // Step 4: Fetch all tasks for the case to check existing locks
        CompletableFuture<List<WorkList>> workListTasksFuture = CompletableFuture.supplyAsync(() -> {
            try {
                Query query = entityManager.createNativeQuery(
                        "SELECT * FROM client_srvc.asign_wl WHERE case_id = :caseId", WorkList.class);
                query.setParameter("caseId", caseIdStr);
                return query.getResultList();
            } catch (PersistenceException e) {
                return List.of();
            }
        });

        CompletableFuture<List<WorkBasket>> workBasketTasksFuture = CompletableFuture.supplyAsync(() -> {
            try {
                Query query = entityManager.createNativeQuery(
                        "SELECT * FROM client_srvc.asign_wb WHERE case_id = :caseId", WorkBasket.class);
                query.setParameter("caseId", caseIdStr);
                return query.getResultList();
            } catch (PersistenceException e) {
                return List.of();
            }
        });

        List<WorkList> workListTasks;
        List<WorkBasket> workBasketTasks;
        try {
            workListTasks = workListTasksFuture.join();
            workBasketTasks = workBasketTasksFuture.join();
        } catch (Exception e) {
            return "Error retrieving tasks for lock checking: " + e.getMessage();
        }

        // Step 5: Check if any task is actively locked
        AtomicBoolean hasActiveLocks = new AtomicBoolean(false);
        AtomicReference<String> lockedByRef = new AtomicReference<>();
        LocalDateTime now = LocalDateTime.now(ZoneId.of("UTC"));

        // Check all WorkList tasks for active locks
        List<WorkList> lockedWorkListTasks = workListTasks.stream()
                .filter(task -> task.getLockedBy() != null && isTaskStillActive(task.getLockedOn()))
                .collect(Collectors.toList());
        if (!lockedWorkListTasks.isEmpty()) {
            hasActiveLocks.set(true);
            lockedByRef.set(lockedWorkListTasks.get(0).getLockedBy());
        }

        // Check all WorkBasket tasks for active locks
        List<WorkBasket> lockedWorkBasketTasks = workBasketTasks.stream()
                .filter(task -> task.getLockedBy() != null && isTaskStillActive(task.getLockedOn()))
                .collect(Collectors.toList());
        if (!lockedWorkBasketTasks.isEmpty() && !hasActiveLocks.get()) {
            hasActiveLocks.set(true);
            lockedByRef.set(lockedWorkBasketTasks.get(0).getLockedBy());
        }

        // Step 6: If any task is actively locked, do not lock the new task
        if (hasActiveLocks.get()) {
            return "Case has an active lock by " + lockedByRef.get() + ". Try again later.";
        }

        // Step 7: Check if all locks are inactive (older than 30 minutes)
        boolean allLocksInactive = workListTasks.stream()
                .filter(task -> task.getLockedBy() != null)
                .allMatch(task -> isTaskInactiveFor30Minutes(task.getLockedOn(), now))
                && workBasketTasks.stream()
                .filter(task -> task.getLockedBy() != null)
                .allMatch(task -> isTaskInactiveFor30Minutes(task.getLockedOn(), now));

        // Step 8: Unlock inactive tasks if all are inactive
        if (allLocksInactive) {
            workListTasks.forEach(task -> {
                if (task.getLockedBy() != null) {
                    task.setLockedBy(null);
                    task.setLockedOn(null);
                    try {
                        entityManager.merge(task);
                    } catch (PersistenceException e) {
                        // Ignore if columns don't exist
                    }
                }
            });
            workBasketTasks.forEach(task -> {
                if (task.getLockedBy() != null) {
                    task.setLockedBy(null);
                    task.setLockedOn(null);
                    try {
                        entityManager.merge(task);
                    } catch (PersistenceException e) {
                        // Ignore if columns don't exist
                    }
                }
            });
        }

        // Step 9: Check if the requested task is already locked
        boolean isRequestedTaskLocked = (workListTask != null && workListTask.getLockedBy() != null) ||
                (workBasketTask != null && workBasketTask.getLockedBy() != null);

        // Step 10: If no active locks and requested task is not locked, lock it
        if (!hasActiveLocks.get() && !isRequestedTaskLocked) {
            return lockAssignment(activityCase, workListTask, workBasketTask, userId);
        }

        // Step 11: If requested task is already locked or conditions not met, return without locking
        return "Task locking conditions not met or task is already locked.";
    }

    private boolean isTaskStillActive(LocalDateTime lockedOn) {
        if (lockedOn == null) {
            return false;
        }
        LocalDateTime now = LocalDateTime.now(ZoneId.of("UTC"));
        Duration duration = Duration.between(lockedOn, now);
        return duration.toMinutes() <= 30;
    }

    private boolean isTaskInactiveFor30Minutes(LocalDateTime lockedOn, LocalDateTime now) {
        if (lockedOn == null) {
            return true; // Treat null as inactive
        }
        Duration duration = Duration.between(lockedOn, now);
        return duration.toMinutes() > 30;
    }

    private String lockAssignment(ActivityCase activityCase, WorkList workListTask, WorkBasket workBasketTask, String userId) {
        LocalDateTime now = LocalDateTime.now(ZoneId.of("UTC"));

        // Lock the ActivityCase
        activityCase.setLockedStatus("LOCKED");
        activityCase.setLockedBy(userId);
        activityCase.setLockedOpname("OpenAssignment");
        activityCase.setLockedOn(now);
        try {
            entityManager.merge(activityCase);
        } catch (PersistenceException e) {
            return "Error updating ActivityCase lock: " + e.getMessage();
        }

        // Lock the specific task in WorkList or WorkBasket
        try {
            if (workListTask != null) {
                workListTask.setLockedBy(userId);
                workListTask.setLockedOn(now);
                entityManager.merge(workListTask);
            } else if (workBasketTask != null) {
                workBasketTask.setLockedBy(userId);
                workBasketTask.setLockedOn(now);
                entityManager.merge(workBasketTask);
            }
        } catch (PersistenceException e) {
            // Ignore if locked_by/locked_on columns don't exist; ActivityCase lock is sufficient
        }

        return "Task locked successfully for user " + userId;
    }
}


package com.example.service;

import com.example.entity.ActivityCase;
import com.example.entity.WorkBasket;
import com.example.entity.WorkList;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceException;
import jakarta.persistence.Query;
import jakarta.transaction.Transactional;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

@ApplicationScoped
public class AssignmentService {

    @Inject
    EntityManager entityManager;

    @Transactional
    public String openAssignment(Long caseId, Long inputTaskId, String userId) {
        // Convert numeric caseId to the expected string format for WorkList/WorkBasket
        String caseIdStr = "AC-ZZ-" + String.format("%010d", caseId); // Adjust format as per your data

        // Step 1: Fetch the ActivityCase record (single query)
        ActivityCase activityCase;
        try {
            Query caseQuery = entityManager.createQuery(
                    "SELECT ac FROM ActivityCase ac WHERE ac.caseId = :caseId", ActivityCase.class);
            caseQuery.setParameter("caseId", caseId);
            activityCase = (ActivityCase) caseQuery.getSingleResult();
            if (activityCase == null) {
                return "Case not found for caseId: " + caseId;
            }
        } catch (Exception e) {
            return "Error retrieving ActivityCase: " + e.getMessage();
        }

        // Step 2: Fetch all tasks from WorkList and WorkBasket in parallel (one query per table)
        CompletableFuture<List<WorkList>> workListTasksFuture = CompletableFuture.supplyAsync(() -> {
            try {
                Query query = entityManager.createNativeQuery(
                        "SELECT * FROM client_srvc.asign_wl WHERE case_id = :caseId", WorkList.class);
                query.setParameter("caseId", caseIdStr);
                return query.getResultList();
            } catch (PersistenceException e) {
                return List.of();
            }
        });

        CompletableFuture<List<WorkBasket>> workBasketTasksFuture = CompletableFuture.supplyAsync(() -> {
            try {
                Query query = entityManager.createNativeQuery(
                        "SELECT * FROM client_srvc.asign_wb WHERE case_id = :caseId", WorkBasket.class);
                query.setParameter("caseId", caseIdStr);
                return query.getResultList();
            } catch (PersistenceException e) {
                return List.of();
            }
        });

        // Combine results with error handling
        List<WorkList> workListTasks;
        List<WorkBasket> workBasketTasks;
        try {
            workListTasks = workListTasksFuture.join();
            workBasketTasks = workBasketTasksFuture.join();
        } catch (Exception e) {
            return "Error retrieving tasks: " + e.getMessage();
        }

        // Step 3: Filter the requested task using streams
        WorkList workListTask = workListTasks.stream()
                .filter(task -> {
                    try {
                        String flowType = task.getFlowType();
                        Long taskId = (flowType != null && !flowType.isEmpty())
                                ? Long.parseLong(flowType.split("\"id\":\"")[1].split("\"")[0])
                                : null;
                        return taskId != null && taskId.equals(inputTaskId);
                    } catch (Exception e) {
                        return false;
                    }
                })
                .findFirst()
                .orElse(null);

        WorkBasket workBasketTask = workBasketTasks.stream()
                .filter(task -> {
                    try {
                        String flowType = task.getFlowType();
                        Long taskId = (flowType != null && !flowType.isEmpty())
                                ? Long.parseLong(flowType.split("\"id\":\"")[1].split("\"")[0])
                                : null;
                        return taskId != null && taskId.equals(inputTaskId);
                    } catch (Exception e) {
                        return false;
                    }
                })
                .findFirst()
                .orElse(null);

        if (workListTask == null && workBasketTask == null) {
            return "Task not found in WorkList or WorkBasket for caseId: " + caseIdStr + " and taskId: " + inputTaskId;
        }

        // Step 4: Check if any task is actively locked using streams
        AtomicBoolean hasActiveLocks = new AtomicBoolean(false);
        AtomicReference<String> lockedByRef = new AtomicReference<>();
        LocalDateTime now = LocalDateTime.now(ZoneId.of("UTC"));

        // Check WorkList tasks for active locks
        workListTasks.stream()
                .filter(task -> task.getLockedBy() != null && isTaskStillActive(task.getLockedOn()))
                .findFirst()
                .ifPresent(task -> {
                    hasActiveLocks.set(true);
                    lockedByRef.set(task.getLockedBy());
                });

        // Check WorkBasket tasks for active locks (if no active locks found in WorkList)
        if (!hasActiveLocks.get()) {
            workBasketTasks.stream()
                    .filter(task -> task.getLockedBy() != null && isTaskStillActive(task.getLockedOn()))
                    .findFirst()
                    .ifPresent(task -> {
                        hasActiveLocks.set(true);
                        lockedByRef.set(task.getLockedBy());
                    });
        }

        // Step 5: If any task is actively locked, do not lock the new task
        if (hasActiveLocks.get()) {
            return "Case has an active lock by " + lockedByRef.get() + ". Try again later.";
        }

        // Step 6: Check if all locks are inactive (older than 30 minutes) using streams
        boolean allLocksInactive = workListTasks.stream()
                .filter(task -> task.getLockedBy() != null)
                .allMatch(task -> isTaskInactiveFor30Minutes(task.getLockedOn(), now))
                && workBasketTasks.stream()
                .filter(task -> task.getLockedBy() != null)
                .allMatch(task -> isTaskInactiveFor30Minutes(task.getLockedOn(), now));

        // Step 7: Unlock inactive tasks if all are inactive
        if (allLocksInactive) {
            workListTasks.forEach(task -> {
                if (task.getLockedBy() != null) {
                    task.setLockedBy(null);
                    task.setLockedOn(null);
                    try {
                        entityManager.merge(task);
                    } catch (PersistenceException e) {
                        // Ignore if columns don't exist
                    }
                }
            });
            workBasketTasksezzaforEach(task -> {
                if (task.getLockedBy() != null) {
                    task.setLockedBy(null);
                    task.setLockedOn(null);
                    try {
                        entityManager.merge(task);
                    } catch (PersistenceException e) {
                        // Ignore if columns don't exist
                    }
                }
            });
        }

        // Step 8: Check if the requested task is already locked
        boolean isRequestedTaskLocked = (workListTask != null && workListTask.getLockedBy() != null) ||
                (workBasketTask != null && workBasketTask.getLockedBy() != null);

        // Step 9: If no active locks and requested task is not locked, lock it
        if (!hasActiveLocks.get() && !isRequestedTaskLocked) {
            return lockAssignment(activityCase, workListTask, workBasketTask, userId);
        }

        // Step 10: If requested task is already locked or conditions not met, return without locking
        return "Task locking conditions not met or task is already locked.";
    }

    private boolean isTaskStillActive(LocalDateTime lockedOn) {
        if (lockedOn == null) {
            return false;
        }
        LocalDateTime now = LocalDateTime.now(ZoneId.of("UTC"));
        Duration duration = Duration.between(lockedOn, now);
        return duration.toMinutes() <= 30;
    }

    private boolean isTaskInactiveFor30Minutes(LocalDateTime lockedOn, LocalDateTime now) {
        if (lockedOn == null) {
            return true; // Treat null as inactive
        }
        Duration duration = Duration.between(lockedOn, now);
        return duration.toMinutes() > 30;
    }

    private String lockAssignment(ActivityCase activityCase, WorkList workListTask, WorkBasket workBasketTask, String userId) {
        LocalDateTime now = LocalDateTime.now(ZoneId.of("UTC"));

        // Lock the ActivityCase
        activityCase.setLockedStatus("LOCKED");
        activityCase.setLockedBy(userId);
        activityCase.setLockedOpname("OpenAssignment");
        activityCase.setLockedOn(now);
        try {
            entityManager.merge(activityCase);
        } catch (PersistenceException e) {
            return "Error updating ActivityCase lock: " + e.getMessage();
        }

        // Lock the specific task in WorkList or WorkBasket
        try {
            if (workListTask != null) {
                workListTask.setLockedBy(userId);
                workListTask.setLockedOn(now);
                entityManager.merge(workListTask);
            } else if (workBasketTask != null) {
                workBasketTask.setLockedBy(userId);
                workBasketTask.setLockedOn(now);
                entityManager.merge(workBasketTask);
            }
        } catch (PersistenceException e) {
            // Ignore if locked_by/locked_on columns don't exist; ActivityCase lock is sufficient
        }

        return "Task locked successfully for user " + userId;
    }
}

package com.example.service;

import com.example.entity.ActivityCase;
import com.example.entity.WorkBasket;
import com.example.entity.WorkList;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceException;
import jakarta.persistence.Query;
import jakarta.transaction.Transactional;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

@ApplicationScoped
public class AssignmentService {

    @Inject
    EntityManager entityManager;

    @Transactional
    public String openAssignment(Long caseId, Long inputTaskId, String userId) {
        // Convert numeric caseId to the expected string format for WorkList/WorkBasket
        String caseIdStr = "AC-ZZ-" + String.format("%010d", caseId); // Adjust format as per your data

        // Step 1: Fetch the ActivityCase record (single query)
        ActivityCase activityCase;
        try {
            Query caseQuery = entityManager.createQuery(
                    "SELECT ac FROM ActivityCase ac WHERE ac.caseId = :caseId", ActivityCase.class);
            caseQuery.setParameter("caseId", caseId);
            activityCase = (ActivityCase) caseQuery.getSingleResult();
            if (activityCase == null) {
                return "Case not found for caseId: " + caseId;
            }
        } catch (Exception e) {
            return "Error retrieving ActivityCase: " + e.getMessage();
        }

        // Step 2: Fetch all tasks from WorkList and WorkBasket in parallel (one query per table)
        CompletableFuture<List<WorkList>> workListTasksFuture = CompletableFuture.supplyAsync(() -> {
            try {
                Query query = entityManager.createNativeQuery(
                        "SELECT * FROM client_srvc.asign_wl WHERE case_id = :caseId", WorkList.class);
                query.setParameter("caseId", caseIdStr);
                return query.getResultList();
            } catch (PersistenceException e) {
                return List.of();
            }
        });

        CompletableFuture<List<WorkBasket>> workBasketTasksFuture = CompletableFuture.supplyAsync(() -> {
            try {
                Query query = entityManager.createNativeQuery(
                        "SELECT * FROM client_srvc.asign_wb WHERE case_id = :caseId", WorkBasket.class);
                query.setParameter("caseId", caseIdStr);
                return query.getResultList();
            } catch (PersistenceException e) {
                return List.of();
            }
        });

        // Combine results with error handling
        List<WorkList> workListTasks;
        List<WorkBasket> workBasketTasks;
        try {
            workListTasks = workListTasksFuture.join();
            workBasketTasks = workBasketTasksFuture.join();
        } catch (Exception e) {
            return "Error retrieving tasks: " + e.getMessage();
        }

        // Step 3: Filter the requested task using streams
        WorkList workListTask = workListTasks.stream()
                .filter(task -> {
                    try {
                        String flowType = task.getFlowType();
                        Long taskId = (flowType != null && !flowType.isEmpty())
                                ? Long.parseLong(flowType.split("\"id\":\"")[1].split("\"")[0])
                                : null;
                        return taskId != null && taskId.equals(inputTaskId);
                    } catch (Exception e) {
                        return false;
                    }
                })
                .findFirst()
                .orElse(null);

        WorkBasket workBasketTask = workBasketTasks.stream()
                .filter(task -> {
                    try {
                        String flowType = task.getFlowType();
                        Long taskId = (flowType != null && !flowType.isEmpty())
                                ? Long.parseLong(flowType.split("\"id\":\"")[1].split("\"")[0])
                                : null;
                        return taskId != null && taskId.equals(inputTaskId);
                    } catch (Exception e) {
                        return false;
                    }
                })
                .findFirst()
                .orElse(null);

        if (workListTask == null && workBasketTask == null) {
            return "Task not found in WorkList or WorkBasket for caseId: " + caseIdStr + " and taskId: " + inputTaskId;
        }

        // Step 4: Check if any task is actively locked using streams
        AtomicBoolean hasActiveLocks = new AtomicBoolean(false);
        AtomicReference<String> lockedByRef = new AtomicReference<>();
        LocalDateTime now = LocalDateTime.now(ZoneId.of("UTC"));

        // Check WorkList tasks for active locks
        workListTasks.stream()
                .filter(task -> task.getLockedBy() != null && isTaskStillActive(task.getLockedOn()))
                .findFirst()
                .ifPresent(task -> {
                    hasActiveLocks.set(true);
                    lockedByRef.set(task.getLockedBy());
                });

        // Check WorkBasket tasks for active locks (if no active locks found in WorkList)
        if (!hasActiveLocks.get()) {
            workBasketTasks.stream()
                    .filter(task -> task.getLockedBy() != null && isTaskStillActive(task.getLockedOn()))
                    .findFirst()
                    .ifPresent(task -> {
                        hasActiveLocks.set(true);
                        lockedByRef.set(task.getLockedBy());
                    });
        }

        // Step 5: If any task is actively locked, do not lock the new task
        if (hasActiveLocks.get()) {
            return "Case has an active lock by " + lockedByRef.get() + ". Try again later.";
        }

        // Step 6: Check if all locks are inactive (older than 30 minutes) using streams
        boolean allLocksInactive = workListTasks.stream()
                .filter(task -> task.getLockedBy() != null)
                .allMatch(task -> isTaskInactiveFor30Minutes(task.getLockedOn(), now))
                && workBasketTasks.stream()
                .filter(task -> task.getLockedBy() != null)
                .allMatch(task -> isTaskInactiveFor30Minutes(task.getLockedOn(), now));

        // Step 7: Unlock inactive tasks if all are inactive
        if (allLocksInactive) {
            workListTasks.forEach(task -> {
                if (task.getLockedBy() != null) {
                    task.setLockedBy(null);
                    task.setLockedOn(null);
                    try {
                        entityManager.merge(task);
                    } catch (PersistenceException e) {
                        // Ignore if columns don't exist
                    }
                }
            });
            workBasketTasksezzaforEach(task -> {
                if (task.getLockedBy() != null) {
                    task.setLockedBy(null);
                    task.setLockedOn(null);
                    try {
                        entityManager.merge(task);
                    } catch (PersistenceException e) {
                        // Ignore if columns don't exist
                    }
                }
            });
        }

        // Step 8: Check if the requested task is already locked
        boolean isRequestedTaskLocked = (workListTask != null && workListTask.getLockedBy() != null) ||
                (workBasketTask != null && workBasketTask.getLockedBy() != null);

        // Step 9: If no active locks and requested task is not locked, lock it
        if (!hasActiveLocks.get() && !isRequestedTaskLocked) {
            return lockAssignment(activityCase, workListTask, workBasketTask, userId);
        }

        // Step 10: If requested task is already locked or conditions not met, return without locking
        return "Task locking conditions not met or task is already locked.";
    }

    private boolean isTaskStillActive(LocalDateTime lockedOn) {
        if (lockedOn == null) {
            return false;
        }
        LocalDateTime now = LocalDateTime.now(ZoneId.of("UTC"));
        Duration duration = Duration.between(lockedOn, now);
        return duration.toMinutes() <= 30;
    }

    private boolean isTaskInactiveFor30Minutes(LocalDateTime lockedOn, LocalDateTime now) {
        if (lockedOn == null) {
            return true; // Treat null as inactive
        }
        Duration duration = Duration.between(lockedOn, now);
        return duration.toMinutes() > 30;
    }

    private String lockAssignment(ActivityCase activityCase, WorkList workListTask, WorkBasket workBasketTask, String userId) {
        LocalDateTime now = LocalDateTime.now(ZoneId.of("UTC"));

        // Lock the ActivityCase
        activityCase.setLockedStatus("LOCKED");
        activityCase.setLockedBy(userId);
        activityCase.setLockedOpname("OpenAssignment");
        activityCase.setLockedOn(now);
        try {
            entityManager.merge(activityCase);
        } catch (PersistenceException e) {
            return "Error updating ActivityCase lock: " + e.getMessage();
        }

        // Lock the specific task in WorkList or WorkBasket
        try {
            if (workListTask != null) {
                workListTask.setLockedBy(userId);
                workListTask.setLockedOn(now);
                entityManager.merge(workListTask);
            } else if (workBasketTask != null) {
                workBasketTask.setLockedBy(userId);
                workBasketTask.setLockedOn(now);
                entityManager.merge(workBasketTask);
            }
        } catch (PersistenceException e) {
            // Ignore if locked_by/locked_on columns don't exist; ActivityCase lock is sufficient
        }

        return "Task locked successfully for user " + userId;
    }
}
